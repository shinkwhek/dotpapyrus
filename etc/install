#!/bin/bash

export PLATFORM
# ---- ---- ---- ---- ---- ---- ---- ---- ---- #
#                 bash? or zsh?                #
# ---- ---- ---- ---- ---- ---- ---- ---- ---- #
is_bash() {
  [ -n "$BASH_VERSION" ]
}
is_zsh() {
  [ -n "$ZSH_VERSION" ]
}


# ---- ----- ----- ---- ----- ----- ---- ---- #
#                   os type??                 #
# ---- ----- ----- ---- ----- ----- ---- ---- #
# shellcheck disable=SC2119
ostype() { uname | lower }
os_detect() {
  export PLATFORM
  case "$(ostype)" in
    *'linux'*)  PLATFORM='linux'   ;;
    *'darwin'*) PLATFORM='osx'     ;;
    *'bsd'*)    PLATFORM='bsd'     ;;
    *)          PLATFORM='unknown' ;;
  esac
}
# is_osx returns true if running OS is Macintosh
is_osx() {
  os_detect
  if [ "$PLATFORM" = "osx" ]; then
    return 0
  else
    return 1
  fi
}
alias is_mac=is_osx
# is_linux returns true if running OS is GNU/Linux
is_linux() {
  os_detect
  if [ "$PLATFORM" = "linux" ]; then
    return 0
  else
    return 1
  fi
}
# is_bsd returns true if running OS is FreeBSD
is_bsd() {
  os_detect
  if [ "$PLATFORM" = "bsd" ]; then
    return 0
  else
    return 1
  fi
}
# get_os returns OS name of the platform that is running
get_os() {
  local os
  for os in osx linux bsd; do
    if is_$os; then
      echo $os
    fi
  done
}

# ---- ----- ----- ---- ----- ----- ---- ---- #
#                  line tool                  # 
# ---- ----- ----- ---- ----- ----- ---- ---- #
e_newline() {
  printf "\n"
}
e_header()  {
  printf " \033[37;1m%s\033[m\n" "$*"
}
e_error()   {
  printf " \033[31m%s\033[m\n" "✖ $*" 1>&2
}
e_warning() {
  printf " \033[31m%s\033[m\n" "$*"
}
e_done()    { 
  printf " \033[37;1m%s\033[m...\033[32mOK\033[m\n" "✔ $*"
}
e_arrow()   { 
  printf " \033[37;1m%s\033[m\n" "➜ $*" 
}
e_indent() {
  for ((i=0; i<${1:-4}; i++)); do
    echon " "
  done
  if [ -n "$2" ]; then
    echo "$2"
  else
    cat <&0
  fi
}
e_success() { printf " \033[37;1m%s\033[m%s...\033[32mOK\033[m\n" "✔ " "$*" }
e_failure() { die "${1:-$FUNCNAME}" }
ink() {
  if [ "$#" -eq 0 -o "$#" -gt 2 ]; then
    echo "Usage: ink <color> <text>"
    echo "Colors:"
    echo "  black, white, red, green, yellow, blue, purple, cyan, gray"
    return 1
  fi

  local open="\033["
  local close="${open}0m"
  local black="0;30m"
  local red="1;31m"
  local green="1;32m"
  local yellow="1;33m"
  local blue="1;34m"
  local purple="1;35m"
  local cyan="1;36m"
  local gray="0;37m"
  local white="$close"

  local text="$1"
  local color="$close"

  if [ "$#" -eq 2 ]; then
    text="$2"
    case "$1" in
      black | red | green | yellow | blue | purple | cyan | gray | white)
        eval color="\$$1"
        ;;
    esac
  fi

  printf "${open}${color}${text}${close}"
}
logging() {
  if [ "$#" -eq 0 -o "$#" -gt 2 ]; then
    echo "Usage: ink <fmt> <msg>"
    echo "Formatting Options:"
    echo "  TITLE, ERROR, WARN, INFO, SUCCESS"
    return 1
  fi

  local color=
  local text="$2"

  case "$1" in
    TITLE)
      color=yellow
      ;;
    ERROR | WARN)
      color=red
      ;;
    INFO)
      color=blue
      ;;
    SUCCESS)
      color=green
      ;;
    *)
      text="$1"
  esac

  timestamp() {
    ink gray "["
    ink purple "$(date +%H:%M:%S)"
    ink gray "] "
  }

  timestamp; ink "$color" "$text"; echo
}
log_pass() { logging SUCCESS "$1" }
log_fail() { logging ERROR "$1" 1>&2 }
log_fail() { logging WARN "$1" }
log_info() { logging INFO "$1" }
log_echo() { logging TITLE "$1" }

# is_exists returns true if executable $1 exists in $PATH
is_exists() {
  which "$1" >/dev/null 2>&1
  return $?
}
# has is wrapper function
has() {
  is_exists "$@"
}
# die returns exit code error and echo error message
die() {
  e_error "$1" 1>&2
  exit "${2:-1}"
}
# is_login_shell returns true if current shell is first shell
is_login_shell() {
  [ "$SHLVL" = 1 ]
}
# is_git_repo returns true if cwd is in git repository
is_git_repo() {
  git rev-parse --is-inside-work-tree &>/dev/null
  return $?
}
# is_screen_running returns true if GNU screen is running
is_screen_running() {
  [ ! -z "$STY" ]
}
# shell_has_started_interactively returns true if the current shell is
# running from command line
shell_has_started_interactively() {
  [ ! -z "$PS1" ]
}
# is_ssh_running returns true if the ssh deamon is available
is_ssh_running() {
  [ ! -z "$SSH_CLIENT" ]
}
# is_number returns true if $1 is int type
is_number() {
  if [ $# -eq 0 ]; then
    cat <&0
  else
    echo "$1"
  fi | grep -E '^[0-9]+$' >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    return 0
  else
    return 1
  fi
}
alias is_int=is_number
alias is_num=is_number
# echon is a script to emulate the -n flag functionality with 'echo'
# for Unix systems that don't have that available.
echon() {
  echo "$*" | tr -d '\n'
}
# noecho is the same as echon
noecho() {
  if [ "$(echo -n)" = "-n" ]; then
    echo "${*:-> }\c"
  else
    echo -n "${@:-> }"
  fi
}
# lower returns a copy of the string with all letters mapped to their lower case.
# shellcheck disable=SC2120
lower() {
  if [ $# -eq 0 ]; then
    cat <&0
  elif [ $# -eq 1 ]; then
    if [ -f "$1" -a -r "$1" ]; then
      cat "$1"
    else
      echo "$1"
    fi
  else
    return 1
  fi | tr "[:upper:]" "[:lower:]"
}
# upper returns a copy of the string with all letters mapped to their upper case.
# shellcheck disable=SC2120
upper() {
  if [ $# -eq 0 ]; then
    cat <&0
  elif [ $# -eq 1 ]; then
    if [ -f "$1" -a -r "$1" ]; then
      cat "$1"
    else
      echo "$1"
    fi
  else
    return 1
  fi | tr "[:lower:]" "[:upper:]"
}
# len returns the length of $1
len() {
  local length
  length="$(echo "$1" | wc -c | sed -e 's/ *//')"
  #echo "$(expr "$length" - 1)"
  echo $(("$length" - 1))
}
# is_empty returns true if $1 consists of $_BLANK_
is_empty() {
  if [ $# -eq 0 ]; then
    cat <&0
  else
    echo "$1"
  fi | grep -E "^[$_BLANK_]*$" >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

# ==== ==== ==== ==== ==== ==== ==== ==== #
#                 DOTFILES                #
# ==== ==== ==== ==== ==== ==== ==== ==== #
if [ -z "${DOTPATH:-}" ]; then
  DOTPATH=~/.dotfiles; export DOTPATH
fi
DOTFILES_GITHUB="https://github.com/shinkwhek/dotpapyrus.git"; export DOTFILES_GITHUB

# shellcheck disable=SC1078,SC1079,SC2016
dotfiles_logo='
..TYT"i.
.VC?<~~.``  .......
.R=??<<__(<_~:::::~(T5J.`    `    `    `    `    `    `    `
`  `  `  `  `  `  `  `  `  `  .#===uzzzzjj-:;;:::::?7TXgaJ.
.9dOlldUzzzwK<W<;;;:::::~~~_<..                                  `
.Brttttd#ZZZZd6=vP>>;;;:::::~~~~_>,
.JSvrrrttdffffW@ttw#?>>>;;::::::~~~~~?,`  `  `  `  `  `  `  `  `  `
`                       .HuzzzvrrdNkkkW@rwuX#???>>>;;;:::::~~~~~4,
`  `  `  `  `  `  ` .BZuuuuzzwMmqqN#uuZZX#=????>>;;;:::::~~~~~4,
.HZZZZuuuudMqqMMZyyfpMI==????>>>;;;:::::~~~~W.        `        `      `
.WyyyZZZZuuWmHMHWfpbkH#lll==?v??>>>;;:::::~~~_b   `       `  `      `
`                   JpfVVyWyZZZXZuudpkqqqqM@llll=1D???>>>;;;::::::~?c     `                    `
`  JpppffVWkyyyZZZZMqqqqqNM0llllld==???y>>>;;;::::~~d,
`   JkbppppfW#VVyyyydNqqqqH#dll=lldWz===dB??>>;;;::::::w.
`    .NqkkkbbppNfffVyWHMqqqmMIWlllld5?Nzlq@?Nz?>>>;;;::::~4
(gqqqkkkbW#pppWH6dHqqmMC?Wlllq8;;?Nu@;;<Wx??>>>;;::::?-
`      dHmmmqqqkMHbbW@lldHmmM1?>Slld5~:::(@:::;;d2???>>;;;::(\
  .NmmmmmmHMqkHN&swZMHHVOc<jzZ_~~(77<<::::<?H????>>>;;;/     `
`    ?NmmmmNMmqmMI==11&J+_~___``....~(JgNggJ.~J2?1????>j%
`         (HmmgMmmmmMzgTMMMMM#=````````._TMMMMM>(8(D?v~_1J"`
`   ,HmmMNgmmHr__(SO6(t.`````````.`7wwA9~~~J<j$``?   `   `   `
`        .WmMMNgmmN````__.````.`.`.``......~~~(B:d``.^ `  `
`  `  MMgHNHmH]``````````````````....~~~?<F(t.(``` `
`     `     `-MmgmMNgM.``````````````.````.....~_W,<+!``  ` `  `  `
`  `HHHHmMHg]```````````````````````.`.`3/ ` `   `
`          .NWWWHHmN  ` ` ````` ```````````._``.t `` `  `
`  `    .NuXWHWM.`  `  `  ``````````` ,``` ` `    `        `
`    4yXXXW[`.  `   `....    `._``   `   `         `
?yOOw]  .<.. `        .7:   `   `   `
`           j<<+]    <~?>-.  .-<___      `          `
`  `     b_(%     .`   `````` .
,..`     ```` ``````    `       `
%_ `  .0. ` ` ` `` ,S.         ...., . .
` .:  ..k+zi-......(+O1Wa,       ?%j5TYY3(!
_...MHb~<<1zWwZwI1<<<jHHa....
` .Jg.JMM##HHHb__~<jMH@gb<~__JMMMMHHHNHHmg, ..
`.JgHMMNNNNNN##MMHHN  .dMMMMMmn_ .MMMHM#HHH@@@@g@@@Mm-.
,MNNNN#N###N#NNN@@HHhZ=<?MMM@<?T(,H@HMMNN####MM@@@ggmmN.
WM###HHMHHHH#NNN@@H#Mb  .MMHH/  .@@@@gMNNNNNN##HHH@@@HM}
d@HHH@@@HHHH#NNNHHHH#Mh.MMMMMH..@@@@@MNNMNNN###HHH@@@MM`
H@HHH@HM@HHHNMNNM@@H###MMNMNNMHH@@@@MNNMNNNN##H#H@@@MHN
.HH@@HH@H@HH#NMMNNMMMH#H#HMMMMH@gg@@MNNNNMNN#HHHHH@HHH##_
,HH@@MHHH@HHH##NMNNM@H#####MH@@@gmmgMNNNNN##HHHHHH@@HHHH_
dHHHgg@HHHHHH##NNMNNH####MMMHH@@@gmNNNHMMM###HHHHHHH##HH)
#HHH@@HHHHM@MHHHMNMNMM#HMgHM#HHHHNMNNN#MM@H#HHH@@HHH##HH[
.#HHHH@@@@@@@MHHH###NNNMMg@@HH##M#NNNNN#H###HHHHHHHHH#H##\
  .HHHHHH@H@HHMMNNNNNNNMMHH@@HHH#######NN#####HHHHHHHHH#H#M`
'
dotfiles_download() {
  if [ -d "$DOTPATH" ]; then
    log_fail "$DOTPATH: already exists"
    exit 1
  fi
  e_newline
  e_header "Downloading dotfiles..."
  if is_exists "git"; then
    # --recursive equals to ...
    # git submodule init
    # git submodule update
    git clone --recursive "$DOTFILES_GITHUB" "$DOTPATH"

  elif is_exists "curl" || is_exists "wget"; then
    # curl or wget
    local tarball="https://github.com/shinkwhek/dotpapyrus/archive/master.tar.gz"
    if is_exists "curl"; then
      curl -L "$tarball"

    elif is_exists "wget"; then
      wget -O - "$tarball"

    fi | tar xvz
    if [ ! -d dotfiles-master ]; then
      log_fail "dotfiles-master: not found"
      exit 1
    fi
    command mv -f dotfiles-master "$DOTPATH"

  else
    log_fail "curl or wget required"
    exit 1
  fi

  e_newline && e_done "Download"
}

dotfiles_deploy() {
  e_newline
  e_header "Deploying dotfiles..."

  if [ ! -d $DOTPATH ]; then
    log_fail "$DOTPATH: not found"
    exit 1
  fi

  cd "$DOTPATH"

  if is_debug; then
    :
  else
    make deploy
  fi &&

    e_newline && e_done "Deploy"
}

dotfiles_initialize() {
  if [ "$1" = "init" ]; then
    e_newline
    e_header "Initializing dotfiles..."

    if [ -f Makefile ]; then
      #DOTPATH="$(dotpath)"
      #export DOTPATH
      #bash "$DOTPATH"/etc/init/init.sh
      make init
    else
      log_fail "Makefile: not found"
      exit 1
    fi
  fi &&

    e_newline && e_done "Initialize"
}


# A script for the file named "install"
dotfiles_install() {
  # 1. Download the repository
  # ==> downloading
  #
  # Priority: git > curl > wget
  dotfiles_download &&

  # 2. Deploy dotfiles to your home directory
  # ==> deploying
  dotfiles_deploy &&

  # 3. Execute all sh files within etc/init/
  # ==> initializing
  dotfiles_initialize "$@"
}
